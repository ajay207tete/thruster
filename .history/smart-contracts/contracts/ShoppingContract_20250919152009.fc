
import "stdlib.fc";

global int lastOrderId;
global map(int, tuple(slice, slice, int)) orders;
global slice ownerAddress;

() createOrder(slice productDetails, slice productImage) impure {
    lastOrderId = lastOrderId + 1;
    tuple(slice, slice, int) newOrder = (productDetails, productImage, 0);
    orders = udict_set(orders, lastOrderId, newOrder);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; Handle TON payment
    if (msg_value > 0) {
        ;; Assume payment for last order
        tuple(slice, slice, int) order = udict_get(orders, lastOrderId);
        if (order != null) {
            int paid = third(order);
            if (paid == 0) {
                slice pd = first(order);
                slice pi = second(order);
                tuple(slice, slice, int) updatedOrder = (pd, pi, 1);
                orders = udict_set(orders, lastOrderId, updatedOrder);
            }
        }
    }
}

() recv_external(slice in_msg) impure {
    ;; Handle external messages
    int op = in_msg~load_uint(32);
    if (op == 0) {
        ;; Set owner
        ownerAddress = get_sender_address();
    } elseif (op == 1) {
        ;; createOrder
        slice productDetails = in_msg~load_ref().begin_parse();
        slice productImage = in_msg~load_ref().begin_parse();
        createOrder(productDetails, productImage);
    }
}

() withdraw() impure {
    ;; Withdraw funds to owner
    if (get_sender_address() != ownerAddress) {
        throw(101);
    }
    int balance = get_balance();
    if (balance > 0) {
        send_raw_message(begin_cell().store_uint(0x10, 6).store_slice(ownerAddress).store_coins(balance).store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1).end_cell(), 64);
    }
}
